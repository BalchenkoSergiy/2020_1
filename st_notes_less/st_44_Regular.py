import re # Імпортую бібліотеку re

#*************************************************************
set_string = 'Это просто строка текста. А это еще одна строка текста'

#*************************************************************
pattern = 'строка'
print('1 -->', pattern in set_string)# 1 --> True

#*************************************************************
# Використовую метод search
# Даний метод шукає строку у патерні всередині

if re.search(pattern, set_string): # Якщо наш патерн є у строці
    print('2 -->', 'Matched')
else:
    print('2 -->', 'No match')# Якщо наш патерн не є у строці
# 2 --> Matched

#*************************************************************
# Можна результат роботи search присвоїти одразу у змінну
res = re.search(pattern, set_string)
print('3 -->', res)
#3 --> <re.Match object; span=(11, 17), match='строка'>
'''
span=(11, 17) - це зріз найденої строки у патерні (індекси)
'''

#*************************************************************
# Можна роздрукувати або присвоїти безпосередньо зріз першого входження строки у патерні:
print('4 -->', res.span())
# 4 --> (11, 17)

#*************************************************************
# Можна роздрукувати або присвоїти початковий індекс першого входження строки у патерні:
print('5 -->', res.start())
#5 --> 11

#*************************************************************
# Можна роздрукувати або присвоїти кінцевий індекс першого входження строки у патерні:
print('6 -->', res.end())
#6 --> 17

#*************************************************************
# Використовую метод match
# На відміну від методу search, даний метод шукає строку на початку патерну
print('7 -->', re.match(pattern, set_string))
# 7 --> None

#*************************************************************
# Використовую метод findall
# Даний метод повертає список всіх знайдених співпадінь
print('8 -->', re.findall(pattern, set_string))
# 8 --> ['строка', 'строка']

#*************************************************************
# Використовую метод split
# Даний метод розділяє строку по заданому патерну, стільки раз, скільки це можливо
print('9 -->', re.split(r'\.', set_string))
# Я за екранував символ "." тому, що даний символ "." використовується як "Любий символ" якщо його не заекранувати
# 9 --> ['Это просто строка текста', ' А это еще одна строка текста']

#*************************************************************
# Я можу вказати максимальну кількість раз, на яку потрібно розбивати нашу строку за допомогою 3-го аргументу
print('10 -->', re.split('ст', set_string, 1))
# 10 --> ['Это про', 'о строка текста. А это еще одна строка текста']

#*************************************************************
# Приклади із використанням символьних класів
# Використовую сим.клас \w
pattern = r'\w'
print('11 -->', re.findall(pattern, set_string))
# 11 --> ['Э', 'т', 'о', 'п', 'р', 'о', 'с', 'т', 'о', 'с', 'т', 'р', 'о', 'к', 'а', 'т', 'е', 'к', 'с', 'т', 'а', 'А', 'э', 'т', 'о', 'е', 'щ', 'е', 'о', 'д', 'н', 'а', 'с', 'т', 'р', 'о', 'к', 'а', 'т', 'е', 'к', 'с', 'т', 'а']

#*************************************************************
# Якщо потрібно шукати не кожен символ окремо то я використовую Квантифікацію. (додаю до класу якесь значення із (?, *, +))
pattern = r'\w+'
print('12 -->', re.findall(pattern, set_string))
# 12 --> ['Это', 'просто', 'строка', 'текста', 'А', 'это', 'еще', 'одна', 'строка', 'текста']

#*************************************************************
# Якщо мені потрібні лише букви "эт" то я використовую [эт]
pattern = r'[эт]'
print('13 -->', re.findall(pattern, set_string))
# 13 --> ['т', 'т', 'т', 'т', 'т', 'э', 'т', 'т', 'т', 'т']

#*************************************************************
# Якщо мені потрібні лише букви "эт" але не посимвольно а і об'єднано то я використовую +
pattern = r'[эт]+'
print('14 -->', re.findall(pattern, set_string))
# 14 --> ['т', 'т', 'т', 'т', 'т', 'эт', 'т', 'т', 'т']

#*************************************************************
# Якщо мені потрібен діапазон символів то я використовую [від-до]
pattern = r'[а-я]+'
print('15 -->', re.findall(pattern, set_string))
# 15 --> ['то', 'просто', 'строка', 'текста', 'это', 'еще', 'одна', 'строка', 'текста']

#*************************************************************
# Якщо мені потрібен діапазон цифр то я використовую [від-до]
pattern = r'[0-9]+'
print('16 -->', re.findall(pattern, set_string))
# 16 --> []

#*************************************************************
# Якщо мені потрібен діапазон букв та цифр то я використовую [від-до]
pattern = r'[а-я0-9]+'
print('17 -->', re.findall(pattern, set_string))
# 17 --> ['то', 'просто', 'строка', 'текста', 'это', 'еще', 'одна', 'строка', 'текста']

#*************************************************************
# Якщо мені потрібен діапазон великих та малих букв то я використовую [від-до]
pattern = r'[а-яА-Я]+'
print('18 -->', re.findall(pattern, set_string))
# 18 --> ['Это', 'просто', 'строка', 'текста', 'А', 'это', 'еще', 'одна', 'строка', 'текста']

#*************************************************************
# Якщо мені потрібно створити пошук який є реєстро незалежним то я використовую flags=re.IGNORECASE
pattern = r'[а-я]+'
print('19 -->', re.findall(pattern, set_string, flags=re.IGNORECASE))
# 19 --> ['Это', 'просто', 'строка', 'текста', 'А', 'это', 'еще', 'одна', 'строка', 'текста']

#*************************************************************
# Я можу шукати вибірку тільки в кінці строки за допомогою $
pattern = r'\w+$'
print('20 -->', re.findall(pattern, set_string, flags=re.IGNORECASE))
# 20 --> ['текста']

#*************************************************************
# Я можу шукати вибірку тільки в початку строки за допомогою ^
pattern = r'^\w+'
print('21 -->', re.findall(pattern, set_string, flags=re.IGNORECASE))
# 21 --> ['Это']

#*************************************************************
# Пишу функцію валідації імейла
cus_email_one = 'mail@mail.com'
cus_email_two = 'kudlay@bank'
cus_email_three = 'mail@google.com.ua'

def validate_email(email):
    return re.match(r'^.+@\w+\.[a-z]{2,6}$', email, re.IGNORECASE)
'''
^ - початок строки
.+ - послідовність любих символів
@ - знак @
\w - буквенний або цифровий символ, або знак підкреслювання
\. - символ ".", але маю заекранувати
[a-z] - перелік можливих символів після "."
{2,6} - довжина послідовності після "."
'''
print('22 -->', validate_email(cus_email_one))
# 22 --> <re.Match object; span=(0, 13), match='mail@mail.com'>

print('23 -->', validate_email(cus_email_two))
# 23 --> None (відсутня частина .[a-z]{2,6}$  в кінці імейлу (.com))

print('24 -->', validate_email(cus_email_three))
# 24 --> None (лишня частина .com.ua)

#*************************************************************
# Для вирішення проблеми я згруповую частинку шаблону у місці після знаку @
# і кажу що ця частина може бути відсутньою або повторюватись до 2-х разів за допомогою (\w+\.){0,2}

def validate_email(email):
    return re.match(r'^.+@(\w+\.){0,2}[a-z]{2,6}$', email, re.IGNORECASE)

print('25 -->', validate_email(cus_email_one))
# 25 --> <re.Match object; span=(0, 13), match='mail@mail.com'>

print('26 -->', validate_email(cus_email_two))
# 26 --> <re.Match object; span=(0, 11), match='kudlay@bank'>

print('27 -->', validate_email(cus_email_three))
# 27 --> <re.Match object; span=(0, 18), match='mail@google.com.ua'>